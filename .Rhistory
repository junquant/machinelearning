library(caret)
# Read the CSV file in the working directory
data <- read.csv("pml-training.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
# Setting the seed for the prediction algorithm
set.seed(123)
# Split the data set into 60 / 40 for the training and test data set
inTrain <- createDataPartition(y=data$classe, p=0.6, list=FALSE)
train <- data[inTrain,]
test <- data[-inTrain,]
# Create a function to check for % NA values in the respective columns
# Returns a data frame of the number of NA rows, number of rows, and % NA
CalcNA <- function(data){
percentageNA <- apply(data,2,FUN=function(x) sum(is.na(x))/length(x))
countNA <- apply(data,2,FUN=function(x) sum(is.na(x)))
countRow <- apply(data,2,FUN=function(x) length(x))
result <- data.frame(cbind(countNA,cbind(countRow,percentageNA)))
}
result<-CalcNA(data)
colnames(result)
names(result)
str(result)
result
rownames(results)
rownames(result)
rownames(result$percentageNA<=0.95)
rownames(result[result$percentageNA<=0.95,])
trainSubset <- result[rownames(result[result$percentageNA<=0.95,]),]
trainSubset
trainSubset <- result[,rownames(result[result$percentageNA<=0.95,])]
rownames(result[result$percentageNA<=0.95,])
populatedCol = rownames(result[result$percentageNA<=0.95,])
trainSubset <- result[,populatedCol]
trainSubset <- result[populatedCol,]
populatedCol = rownames(result[result$percentageNA<=0.95,])
trainSubset <- data[populatedCol,]
trainSubset
trainSubset <- data[,populatedCol]
trainSubset <- train[,populatedCol]
trainSubset <- train[,populatedCol]
testSubset <- test[,populatedCol]
fTrain <- train[,populatedCol]
fTest <- test[,populatedCol]
library(caret)
# Read the CSV file in the working directory
data <- read.csv("pml-training.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
# Setting the seed for the prediction algorithm
set.seed(123)
# Split the data set into 60 / 40 for the training and test data set
inTrain <- createDataPartition(y=data$classe, p=0.6, list=FALSE)
train <- data[inTrain,]
test <- data[-inTrain,]
# Create a function to check for % NA values in the respective columns
# Returns a data frame of the number of NA rows, number of rows, and % NA
CalcNA <- function(data){
percentageNA <- apply(data,2,FUN=function(x) sum(is.na(x))/length(x))
countNA <- apply(data,2,FUN=function(x) sum(is.na(x)))
countRow <- apply(data,2,FUN=function(x) length(x))
result <- data.frame(cbind(countNA,cbind(countRow,percentageNA)))
}
# Remove columns with more than 95% NA values
populatedCol = rownames(result[result$percentageNA<=0.95,])
fTrain <- train[,populatedCol]
fTest <- test[,populatedCol]
# Loading required libraries
library(caret)
# Read the CSV file in the working directory
data <- read.csv("pml-training.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
# Setting the seed for the prediction algorithm
set.seed(123)
# Split the data set into 60 / 40 for the training and test data set
inTrain <- createDataPartition(y=data$classe, p=0.6, list=FALSE)
train <- data[inTrain,]
test <- data[-inTrain,]
# Create a function to check for % NA values in the respective columns
# Returns a data frame of the number of NA rows, number of rows, and % NA
CalcNA <- function(data){
percentageNA <- apply(data,2,FUN=function(x) sum(is.na(x))/length(x))
countNA <- apply(data,2,FUN=function(x) sum(is.na(x)))
countRow <- apply(data,2,FUN=function(x) length(x))
result <- data.frame(cbind(countNA,cbind(countRow,percentageNA)))
}
# Remove columns with more than 95% NA values
result <- CalcNA(data)
populatedCol = rownames(result[result$percentageNA<=0.95,])
fTrain <- train[,populatedCol]
fTest <- test[,populatedCol]
str(fTrain)
summary(fTrain)
-1:7
-1:-7
fTrain[c(-1:-7),]
head(fTrain[c(-1:-7),])
head(fTrain[,c(-1:-7)])
fTrain <- fTrain[,c(-1:-7)]
fTest <- fTest[,c(-1:-7)]
fTrain
head(fTrian)
head(fTrain)
model <- train(classe~.,method="glm",data=fTrain[1:100,], family="binomial")
fTrain[1:100,]
model <- train(classe~.,method="glm",data=fTrain[1:10,], family="binomial")
warnings()
str(fTrain$classe)
CalcNA(fTraing)
CalcNA(fTrain)
CalcNA <- function(data){
percentageNA <- apply(data,2,FUN=function(x) sum(is.na(x))/length(x))
countNA <- apply(data,2,FUN=function(x) sum(is.na(x)))
countRow <- apply(data,2,FUN=function(x) length(x))
result <- data.frame(cbind(countNA,cbind(countRow,percentageNA)))
return(result)
}
CalcNA(fTrain)
plot(fTrain)
?train
model <- train(classe~.,method="glm",data=fTrain[1:10,], family=binomial())
model <- train(classe~.,method="glm",data=fTrain[1:10,], family=binomial)
model <- train(classe~.,method="glm",data=fTrain[1:10,], family=binomial(link="logit"))
plot(fTrain$magnet_belt_z)
plot(fTrain$magnet_belt_z. fTrain$classe)
plot(fTrain$magnet_belt_z, fTrain$classe)
featurePlot(x=fTrain[,1:5], y=fTrain$classe)
featurePlot(x=fTrain[,1:5], y=fTrain$classe, plot=pairs)
featurePlot(x=fTrain[,1:5], y=fTrain$classe, plot="pairs")
model <- train(classe~.,method="gbm",data=fTrain[1:10,])
warnings()
model <- train(classe~.,method="gbm",data=fTrain[1:100,])
warnings()
model <- train(classe~.,method="rf",data=fTrain[1:100,])
warnings()
str(fTraing)
str(fTrain)
summary(fTrain)
model <- train(classe~.,method="rpart",data=fTrain[1:100,])
str(fTraiin)
str(fTrain)
model <- train(classe~.,method="rpart",data=fTrain[1:100,])
model <- train(classe~.,method="rpart",data=fTrain[1:100,])
model <- train(classe~.,method="tree",data=fTrain[1:100,])
model <- train(classe~.,method="party",data=fTrain[1:100,])
model <- train(classe~.,method="rpart",data=fTrain[1:100,])
train(classe~.,method="rpart",data=fTrain[1:100,])
# Loading required libraries
library(caret)
# Read the CSV file in the working directory
data <- read.csv("pml-training.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
# Setting the seed for the prediction algorithm
set.seed(123)
# Split the data set into 60 / 40 for the training and test data set
inTrain <- createDataPartition(y=data$classe, p=0.6, list=FALSE)
train <- data[inTrain,]
test <- data[-inTrain,]
# Create a function to check for % NA values in the respective columns
# Returns a data frame of the number of NA rows, number of rows, and % NA
CalcNA <- function(data){
percentageNA <- apply(data,2,FUN=function(x) sum(is.na(x))/length(x))
countNA <- apply(data,2,FUN=function(x) sum(is.na(x)))
countRow <- apply(data,2,FUN=function(x) length(x))
result <- data.frame(cbind(countNA,cbind(countRow,percentageNA)))
return(result)
}
# Remove columns with more than 95% NA values
result <- CalcNA(data)
populatedCol = rownames(result[result$percentageNA<=0.95,])
fTrain <- train[,populatedCol]
fTest <- test[,populatedCol]
# Remove columns timestamps and identifiers (eg. ID) columns
fTrain <- fTrain[,c(-1:-7)]
fTest <- fTest[,c(-1:-7)]
model <- train(classe~.,method="rpart",data=fTrain[1:100,])
modFit <- train(Species~., method="rpart", data=iris)
modFit
head(fTrain)
head(train)
model <- train(classe~.,method="rpart",data=fTrain[1:100,])
model <- train(classe~.,method="rpart",data=fTrain[1:1000,])
model <- train(classe~.,method="rpart",data=fTrain[1:5000,])
?predict
predict(model,fTest)
x<-predict(model,fTest)
?confusionMatrix
confusionMatrix(fTest,x)
confusionMatrix(fTest$classe,x)
confusionMatrix(fTrain$classe,x)
fTrain$classe
confusionMatrix(fTrain$classe[1:5000,],x)
confusionMatrix(fTrain[1:5000,]$classe,x)
confusionMatrix(fTrain$classe[1:5000],x)
fTrain$classe[1]
fTrain$classe[1:5000]
model <- train(classe~.,method="rpart",data=fTrain)
x<-predict(model,fTest$classe)
x<-predict(model,fTest)
confusionMatrix(model,x)
confusionMatrix(fTest,x)
confusionMatrix(fTest$classe,x)
model <- train(classe~.,method="rf",data=fTrain)
predict(model, fTest$classe)
predict(model,fTrain$classe)
predict(model,fTest)
x<-predict(model,fTest)
confusionMatrix(x,fTest)
confusionMatrix(x,fTest$classe)
?save
?saveRDS
?data
saveRDS(model,"model_rf.rds")
# Loading required libraries
library(caret)
# Read the CSV file in the working directory
data <- read.csv("pml-training.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
# Setting the seed for the prediction algorithm
set.seed(123)
# Split the data set into 60 / 40 for the training and test data set
inTrain <- createDataPartition(y=data$classe, p=0.6, list=FALSE)
train <- data[inTrain,]
test <- data[-inTrain,]
# Create a function to check for % NA values in the respective columns
# Returns a data frame of the number of NA rows, number of rows, and % NA
CalcNA <- function(data){
percentageNA <- apply(data,2,FUN=function(x) sum(is.na(x))/length(x))
countNA <- apply(data,2,FUN=function(x) sum(is.na(x)))
countRow <- apply(data,2,FUN=function(x) length(x))
result <- data.frame(cbind(countNA,cbind(countRow,percentageNA)))
return(result)
}
# Remove columns with more than 95% NA values
result <- CalcNA(data)
populatedCol = rownames(result[result$percentageNA<=0.95,])
fTrain <- train[,populatedCol]
fTest <- test[,populatedCol]
# Remove columns timestamps and identifiers (eg. ID) columns
fTrain <- fTrain[,c(-1:-7)]
fTest <- fTest[,c(-1:-7)]
model <- readRDS("model_rf.rds")
outcome <- predict(model, fTest)
confusionMatrix(outcome,fTest)
confusionMatrix(outcome,fTest$classe)
submissionData <- read.csv("pml-testing.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
# Perform the necessary clean up
sfData <- submissionData[,populatedCol]
finalOutcome <- predict(model, submissionData)
# Loading required libraries
library(caret)
# Read the CSV file in the working directory
data <- read.csv("pml-training.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
# Setting the seed for the prediction algorithm
set.seed(123)
# Split the data set into 60 / 40 for the training and test data set
inTrain <- createDataPartition(y=data$classe, p=0.6, list=FALSE)
train <- data[inTrain,]
test <- data[-inTrain,]
# Create a function to check for % NA values in the respective columns
# Returns a data frame of the number of NA rows, number of rows, and % NA
CalcNA <- function(data){
percentageNA <- apply(data,2,FUN=function(x) sum(is.na(x))/length(x))
countNA <- apply(data,2,FUN=function(x) sum(is.na(x)))
countRow <- apply(data,2,FUN=function(x) length(x))
result <- data.frame(cbind(countNA,cbind(countRow,percentageNA)))
return(result)
}
# Remove columns with more than 95% NA values
result <- CalcNA(data)
populatedCol = rownames(result[result$percentageNA<=0.95,])
fTrain <- train[,populatedCol]
fTest <- test[,populatedCol]
# Remove columns timestamps and identifiers (eg. ID) columns
fTrain <- fTrain[,c(-1:-7)]
fTest <- fTest[,c(-1:-7)]
# Build / Save / Read the Model to test it
# model <- train(classe~.,method="rf",data=fTrain)
# saveRDS(model,"model_rf.rds")
model <- readRDS("model_rf.rds")
# Use the model to predict the classe variable
outcome <- predict(model, fTest)
# Assess the performance of the model
confusionMatrix(outcome,fTest$classe)
#######################################################################
# Read the test data for submission
submissionData <- read.csv("pml-testing.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
# Perform the necessary clean up
sfData <- submissionData[,populatedCol]
sfData <- sfData[,c(-1:-7)]
finalOutcome <- predict(model, submissionData)
# Loading required libraries
library(caret)
# Read the CSV file in the working directory
data <- read.csv("pml-training.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
# Setting the seed for the prediction algorithm
set.seed(123)
# Split the data set into 60 / 40 for the training and test data set
inTrain <- createDataPartition(y=data$classe, p=0.6, list=FALSE)
train <- data[inTrain,]
test <- data[-inTrain,]
# Create a function to check for % NA values in the respective columns
# Returns a data frame of the number of NA rows, number of rows, and % NA
CalcNA <- function(data){
percentageNA <- apply(data,2,FUN=function(x) sum(is.na(x))/length(x))
countNA <- apply(data,2,FUN=function(x) sum(is.na(x)))
countRow <- apply(data,2,FUN=function(x) length(x))
result <- data.frame(cbind(countNA,cbind(countRow,percentageNA)))
return(result)
}
# Remove columns with more than 95% NA values
result <- CalcNA(data)
populatedCol = rownames(result[result$percentageNA<=0.95,])
fTrain <- train[,populatedCol]
fTest <- test[,populatedCol]
# Remove columns timestamps and identifiers (eg. ID) columns
fTrain <- fTrain[,c(-1:-7)]
fTest <- fTest[,c(-1:-7)]
# Build / Save / Read the Model to test it
# model <- train(classe~.,method="rf",data=fTrain)
# saveRDS(model,"model_rf.rds")
model <- readRDS("model_rf.rds")
# Use the model to predict the classe variable
outcome <- predict(model, fTest)
# Assess the performance of the model
confusionMatrix(outcome,fTest$classe)
#######################################################################
# Read the test data for submission
submissionData <- read.csv("pml-testing.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
finalOutcome <- predict(model, submissionData)
finalOutcome
str(finalOutcome)
finalOutcome <- as.vector(finalOutcome)
pml_write_files = function(x){
n = length(x)
for(i in 1:n){
filename = paste0("problem_id_",i,".txt")
write.table(x[i],file=filename,quote=FALSE,row.names=FALSE,col.names=FALSE)
}
}
?paste
?paste0
pml_write_files(paste0("outcome/",finalOutcome))
pml_write_files = function(x){
n = length(x)
for(i in 1:n){
filename = paste0("outcome/problem_id_",i,".txt")
write.table(x[i],file=filename,quote=FALSE,row.names=FALSE,col.names=FALSE)
}
}
pml_write_files(finalOutcome)
pml_write_files = function(x){
n = length(x)
for(i in 1:n){
filename = paste0("/outcome/problem_id_",i,".txt")
write.table(x[i],file=filename,quote=FALSE,row.names=FALSE,col.names=FALSE)
}
}
pml_write_files(finalOutcome)
pml_write_files = function(x){
n = length(x)
for(i in 1:n){
filename = paste0("outcome/problem_id_",i,".txt")
write.table(x[i],file=filename,quote=FALSE,row.names=FALSE,col.names=FALSE)
}
}
pml_write_files(finalOutcome)
model <- readRDS("model_rf.rds")
model
str(model)
model$predictors
model$modelinfo
model$modelInfo
model$modelInfo$predictors
?trainControl
library(caret)
data <- read.csv("pml-training.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
data <- read.csv("pml-training.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
summary(data)
library(caret)
data <- read.csv("pml-training.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
summary(data)
# Remove columns timestamps and identifiers (eg. ID) columns
data <- data[,c(-1:-7)]
# Create a function to check for % NA values in the respective columns
# Returns a data frame of the number of NA rows, number of rows, and % NA
CalcNA <- function(data){
percentageNA <- apply(data,2,FUN=function(x) sum(is.na(x))/length(x))
countNA <- apply(data,2,FUN=function(x) sum(is.na(x)))
countRow <- apply(data,2,FUN=function(x) length(x))
result <- data.frame(cbind(countNA,cbind(countRow,percentageNA)))
return(result)
}
result <- CalcNA(data)
includedCol = rownames(result[result$percentageNA<=0.95,])
data <- data[,includedCol]
set.seed(123)
# Split the data set into 60 / 40 for the training and test data set
inTrain <- createDataPartition(y=data$classe, p=0.6, list=FALSE)
train <- data[inTrain,]
test <- data[-inTrain,]
# Build / Save / Read the Model to test it
model <- train(classe~.,method="rf",preProcess="pca", data=train)
warnings()
saveRDS(model,"model_rf_pca.rds")
outcome <- predict(model, test)
confusionMatrix(outcome,test$classe)
model <- readRDS("model_rf.rds")
outcome <- predict(model, test)
confusionMatrix(outcome,test$classe)
sys.time()
Sys.time()
Sys.time()
model <- train(classe~.,method="gbm", data=train)
model <- readRDS("model_gbm.rds")
saveRDS(model,"model_gbm.rds")
outcome <- predict(model, test)
confusionMatrix(outcome,test$classe)
submissionData <- read.csv("pml-testing.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
# Predict the outcome
finalOutcome <- predict(model, submissionData)
finalOutcome <- as.vector(finalOutcome)
pml_write_files = function(x){
n = length(x)
for(i in 1:n){
filename = paste0("outcome/problem_id_",i,".txt")
write.table(x[i],file=filename,quote=FALSE,row.names=FALSE,col.names=FALSE)
}
}
pml_write_files(finalOutcome)
finalOutcome <- predict(model, submissionData)
finalOutcome <- as.vector(finalOutcome)
pml_write_files(finalOutcome)
model <- readRDS("model_rf.rds")
finalOutcome <- predict(model, submissionData)
finalOutcome <- as.vector(finalOutcome)
pml_write_files(finalOutcome)
model <- readRDS("model_rf.rds")
outcome <- predict(model, test)
confusionMatrix(outcome,test$classe)
inTrain <- createDataPartition(y=data$classe, p=0.6, list=FALSE)
train <- data[inTrain,]
traintest <- data[-inTrain,]
outcome <- predict(model, traintest)
confusionMatrix(outcome,test$classe)
set.seed(123)
# Split the data set into 60 / 40 for the training and test data set
inTrain <- createDataPartition(y=data$classe, p=0.6, list=FALSE)
train <- data[inTrain,]
traintest <- data[-inTrain,]
outcome <- predict(model, traintest)
confusionMatrix(outcome,test$classe)
system.time(model <- train(classe~.,method="rf", data=train))
rm(model)
system.time(model <- train(classe~.,method="rf", data=train))
outcome <- predict(model, traintest)
confusionMatrix(outcome,test$classe)
set.seed(123)
train <- data[inTrain,]
traintest <- data[-inTrain,]
outcome <- predict(model, traintest)
confusionMatrix(outcome,test$classe)
model.outofsample.error
model$overall[1]
confusionMatrix(outcome,test$classe)$overall[1]
finalOutcome
model
str(model)
model$finalModel
model
trainCtrl <- trainControl(method="cv", number=3)
library(caret)
data <- read.csv("pml-training.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
summary(data)
data <- data[,c(-1:-7)]
CalcNA <- function(data){
percentageNA <- apply(data,2,FUN=function(x) sum(is.na(x))/length(x))
countNA <- apply(data,2,FUN=function(x) sum(is.na(x)))
countRow <- apply(data,2,FUN=function(x) length(x))
result <- data.frame(cbind(countNA,cbind(countRow,percentageNA)))
return(result)
}
result <- CalcNA(data)
includedCol = rownames(result[result$percentageNA<=0.95,])
data <- data[,includedCol]
set.seed(123)
inTrain <- createDataPartition(y=data$classe, p=0.6, list=FALSE)
train <- data[inTrain,]
traintest <- data[-inTrain,]
trainCtrl <- trainControl(method="cv", number=5)
set.seed(456)
model <- train(classe~.,method="rf", data=train, trControl=trainCtrl)
saveRDS(model,"model_rf.rds")
outcome <- predict(model, traintest)
confusionMatrix(outcome,test$classe)
confusionMatrix(outcome,traintest$classe)
submissionData <- read.csv("pml-testing.csv", na.strings=c("#DIV/0","#DIV/0!","NA"))
# Predict the outcome
finalOutcome <- predict(model, submissionData)
finalOutcome <- as.vector(finalOutcome)
finalOutcome
model$finalModel
confusionMatrix(outcome,traintest$classe)$Accuracy
confusionMatrix(outcome,traintest$classe)$accuracy
confusionMatrix(outcome,traintest$classe)
str(confusionMatrix(outcome,traintest$classe))
confusionMatrix(outcome,traintest$classe)$overall$accuracy
confusionMatrix(outcome,traintest$classe)$overall
confusionMatrix(outcome,traintest$classe)$overall[1]
1- confusionMatrix(outcome,traintest$classe)$overall[1]
errorRateEstimate <- 1 - confusionMatrix(outcome,traintest$classe)$overall
errorRateEstimate
errorRateEstimate <- 1 - confusionMatrix(outcome,traintest$classe)$overall[1]
errorRateEstimate
errorRateEstimate[1]
errorRateEstimate <- as.vector(1 - confusionMatrix(outcome,traintest$classe)$overall[1])
errorRateEstimate
source('~/.active-rstudio-document', echo=TRUE)
errorRateEstimate
